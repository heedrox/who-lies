# 0003_PLAN.md - Sistema de Bombas del Asesino

## Descripción de la Funcionalidad

Implementar un sistema de bombas que permite al asesino colocar una bomba durante la fase de movimiento. La mecánica incluye:

- **Colocación**: Durante la fase de movimiento, el asesino puede colocar una bomba en su habitación actual o en una de las habitaciones contiguas
- **Interfaz**: Botones "SOLTAR BOMBA" aparecen en habitaciones válidas durante el modo de movimiento
- **Visualización**: Emoji de bomba 💣 visible solo para el asesino en el mapa
- **Restricciones**: Solo una bomba por partida, no se puede quitar una vez colocada
- **Persistencia**: La bomba permanece visible en rondas posteriores
- **Mecánica de muerte**: Cuando termina la fase de movimiento, si el jugador objetivo se mueve a una habitación con bomba, muere automáticamente

## Archivos y Funciones a Modificar

### 1. Estructura de Base de Datos (Firebase)

**Archivo**: `web/firebase-modular.js`

**Funciones a modificar**:
- `savePlayerDistribution()` - Agregar campos iniciales de bombas
- `finalizeRound()` - Limpiar campos de bombas si es necesario
- `updateGameState()` - Soporte para actualizaciones de bombas

**Nuevos campos en la estructura de datos**:
```javascript
{
  // ... campos existentes ...
  bombPlaced: null,          // null o "cocina" (nombre de la habitación)
}
```

### 2. Lógica de Colocación de Bombas

**Archivo**: `web/firebase-modular.js`

**Nuevas funciones a crear**:
- `placeBomb(gameCode, roomName)` - Colocar bomba con validaciones
- `getBombLocation(gameCode)` - Obtener ubicación de la bomba (null si no hay)
- `validateBombPlacement(playerNumber, roomName, gameData)` - Validar si se puede colocar bomba
- `getBombEligibleRooms(playerNumber, gameData)` - Obtener habitaciones donde se puede colocar bomba

**Validaciones a implementar**:
- Solo el asesino puede colocar bombas
- Solo en habitación actual o contiguas
- Solo una bomba por partida
- Solo durante fase de movimiento

### 3. Interfaz de Usuario para Colocación

**Archivo**: `web/index.html`

**Funciones a modificar**:
- `enableRoomSelection()` - Agregar lógica para mostrar botones de bomba
- `handleRoomSelection()` - Integrar colocación de bomba con movimiento
- `isRoomAccessible()` - Incluir validación de bombas

**Nuevas funciones a crear**:
- `showBombButtons(gameData)` - Mostrar botones "SOLTAR BOMBA" en habitaciones válidas
- `hideBombButtons()` - Ocultar botones de bomba
- `handleBombPlacement(roomName)` - Manejar clic en botón de bomba
- `isBombPlacementAllowed(playerNumber, roomName, gameData)` - Validar si se puede colocar bomba

**Funciones existentes a reutilizar**:
- `getCurrentPlayerRoom(playerNumber, distribution)` - Obtener habitación actual del jugador
- `isRoomAccessible(targetRoom, currentPlayer, playerRole, gameData)` - Lógica de habitaciones contiguas

**Elementos UI a agregar**:
- Botones "SOLTAR BOMBA" pequeños en habitaciones válidas
- Integración con el sistema de movimiento existente

### 4. Visualización de Bombas en el Mapa

**Archivo**: `web/index.html`

**Funciones a modificar**:
- `updateRoomDisplay()` - Agregar emoji de bomba en la habitación correspondiente
- `handleGameUpdate()` - Procesar actualizaciones de la bomba en tiempo real

**Nuevas funciones a crear**:
- `renderBombInRoom(roomElement, hasBomb)` - Mostrar/ocultar emoji de bomba
- `updateBombVisibility(gameData)` - Actualizar visibilidad de la bomba según rol del jugador

**Elementos UI a agregar**:
- Emoji 💣 en la habitación con bomba (solo visible para asesino)
- Estilos CSS para el emoji de bomba

### 5. Mecánica de Muerte por Bomba

**Archivo**: `web/firebase-modular.js` y `web/index.html`

**Funciones a modificar**:
- `finalizeRound()` - Agregar lógica para verificar muertes por bomba
- `calculateNewDistribution()` - Considerar muertes por bomba al calcular nueva distribución

**Nuevas funciones a crear**:
- `checkBombDeaths(gameData, newDistribution)` - Verificar si algún jugador muere por bomba
- `processBombDeaths(gameData, newDistribution)` - Procesar muertes por bomba

## Algoritmo de Colocación de Bombas

### Paso 1: Validación de Colocación
1. Verificar que el jugador es el asesino (`gameData.roles.ASESINO === playerNumber`)
2. Verificar que estamos en fase de movimiento (`gameData.endingRound === true`)
3. Verificar que no hay bomba colocada previamente (`gameData.bombPlaced === null`)
4. Verificar que la habitación es la actual o contigua usando `roomMovements`

### Paso 2: Obtención de Habitaciones Válidas
1. Obtener habitación actual del asesino: `getCurrentPlayerRoom(playerNumber, gameData.playerDistribution)`
2. Obtener habitaciones contiguas: `roomMovements[currentRoom]`
3. Incluir habitación actual en la lista de habitaciones válidas
4. Filtrar solo habitaciones que no sean 'centro'

### Paso 3: Procesamiento de Colocación
1. Actualizar campo `bombPlaced` con el nombre de la habitación
2. Ocultar botones de bomba
3. Continuar con movimiento normal

### Paso 4: Visualización
1. Solo el asesino ve el emoji de bomba en la habitación correspondiente
2. La bomba persiste entre rondas
3. Sincronización en tiempo real con Firebase

### Paso 5: Mecánica de Muerte por Bomba
1. Al finalizar la fase de movimiento, verificar si hay bomba colocada
2. Para cada jugador que se movió, verificar si su nueva ubicación tiene bomba
3. Si un jugador se mueve a una habitación con bomba, marcarlo como muerto
4. Procesar la muerte junto con las otras muertes de la ronda

## Fases de Implementación

### Fase 1: Estructura de Datos (Feature 1)
- Modificar `savePlayerDistribution()` para incluir campos de bombas
- Actualizar `finalizeRound()` para manejar bombas
- Crear funciones básicas de validación

### Fase 2: Lógica de Colocación (Feature 2)
- Implementar `placeBomb()` con todas las validaciones
- Crear `validateBombPlacement()` con reglas de negocio
- Integrar con sistema de fases existente

### Fase 3: Interfaz de Colocación (Feature 3)
- Modificar `enableRoomSelection()` para mostrar botones de bomba
- Crear `handleBombPlacement()` para manejar clics
- Integrar con flujo de movimiento existente

### Fase 4: Visualización (Feature 4)
- Modificar `updateRoomDisplay()` para mostrar emojis de bomba
- Implementar `updateBombVisibility()` para control de visibilidad
- Asegurar sincronización en tiempo real

### Fase 5: Mecánica de Muerte (Feature 5)
- Modificar `finalizeRound()` para verificar muertes por bomba
- Implementar `checkBombDeaths()` y `processBombDeaths()`
- Integrar con sistema de muertes existente

## Consideraciones Técnicas

### Integración con Sistema Existente
- Reutilizar sistema de fases (`endingRound`)
- Integrar con sistema de movimiento existente
- Mantener compatibilidad con roles y visibilidad

### Sincronización en Tiempo Real
- Usar `subscribeToGameUpdates()` existente
- Actualizar UI automáticamente cuando cambie la bomba
- Mantener consistencia entre jugadores

### Persistencia de Datos
- La bomba persiste entre rondas
- Limpieza automática al reiniciar juego

### Experiencia de Usuario
- Botones pequeños y discretos
- Integración fluida con movimiento
- Feedback visual claro para el asesino

## Validaciones de Negocio

1. **Solo asesino**: Verificar `gameData.roles.ASESINO === playerNumber`
2. **Solo en fase de movimiento**: Verificar `gameData.endingRound === true`
3. **Solo una bomba**: Verificar `gameData.bombPlaced === null`
4. **Habitación válida**: Verificar que la habitación es actual o contigua usando `roomMovements`
5. **Jugador vivo**: Verificar que el asesino no está en `gameData.deads`

## Estructura de Datos Detallada

```javascript
// Ejemplo de datos de bomba en Firebase
{
  // ... otros campos del juego ...
  bombPlaced: "cocina"  // Nombre de la habitación donde está la bomba
}

// O si no hay bomba colocada:
{
  // ... otros campos del juego ...
  bombPlaced: null
}
```

## Notas de Implementación

- Mantener compatibilidad con el sistema de roles existente
- Reutilizar funciones existentes: `getCurrentPlayerRoom()` e `isRoomAccessible()`
- Usar el diccionario `roomMovements` para determinar habitaciones contiguas
- Integrar con el sistema de suscripciones en tiempo real
- Asegurar que la UI se actualiza correctamente en todos los dispositivos
- Mantener la estética visual consistente con el resto del juego

## Diccionario de Habitaciones Contiguas (roomMovements)

```javascript
const roomMovements = {
    'cocina': ['pasillo_norte', 'comedor'],
    'pasillo_norte': ['cocina', 'habitacion_principal'],
    'habitacion_principal': ['pasillo_norte', 'habitacion_invitados'],
    'comedor': ['cocina', 'torreon_oeste'],
    'habitacion_invitados': ['habitacion_principal', 'torreon_este'],
    'torreon_oeste': ['comedor', 'pasillo_sur'],
    'pasillo_sur': ['torreon_oeste', 'torreon_este'],
    'torreon_este': ['pasillo_sur', 'habitacion_invitados']
};
```